# In Silico Framework
# Copyright (C) 2025  Max Planck Institute for Neurobiology of Behavior - CAESAR

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
# The full license text is also available in the LICENSE file in the root of this repository.

'''
ongoing activity L2 neuron model
'''
from __future__ import absolute_import
from ._matplotlib_import import *
import sys
import time
import os, os.path
import glob
import neuron
import single_cell_parser as scp
import single_cell_parser.analyze as sca
import numpy as np

h = neuron.h
import dask
import pandas as pd
import socket
from . import utils
import logging

logger = logging.getLogger("ISF").getChild(__name__)

__author__ = ['Robert Egger', 'Arco Bast']
__date__ = '2013-01-28'

def _evoked_activity(
    cellParamName, 
    evokedUpParamName, 
    synapse_activation_files,
    dirPrefix = '', 
    tStop = 345.0, 
    scale_apical = None, 
    post_hook = {}, 
    auto_organize_results_folder = True,
    cell_generator = None
    ):
    '''
    :skip-doc:
    Recreate and resimulate a network-embedded neuron simulation from a list of :ref:`syn_activation_format` files.
    
    Private function that is called by :func:`run_existing_synapse_activations`.
    
    Args:
        cellParamName (str): Path to a :ref:`cell_parameters_format` file 
        evokedUpParamName (str): Path to a :ref:`network_parameters_format` file
        synapse_activation_files (list): List of paths to :ref:`syn_activation_format` files
        dirPrefix (str): Path to the directory where the simulation results should be stored.
        tStop (float): Time in ms at which the synaptic input should stop.
        scale_apical (float, DEPRECATED): Scaling factor for the apical dendrite.
        post_hook (dict): Dictionary of functions that are called after the simulation.
        auto_organize_results_folder (bool): If True, the results are stored in a subfolder of the results folder.
        cell_generator (function): Function that generates a cell object.
        
    Returns: 
        dask.delayed: Delayed object. Can be computed with arbitrary scheduler.
        
    .. deprecated:: 0.1
        The `scale_apical` argument is deprecated and will be removed in a future version.
        Use the ``cell_modify_functions`` key in the :ref:`cell_parameters_format` file instead.
    '''

    if len(synapse_activation_files) == 0:
        logger.warning('empty_simulation')
        return

    neuronParameters = utils.load_param_file_if_path_is_provided(cellParamName)
    evokedUpNWParameters = utils.load_param_file_if_path_is_provided(
        evokedUpParamName)

    scp.load_NMODL_parameters(neuronParameters)
    scp.load_NMODL_parameters(evokedUpNWParameters)
    cellParam = neuronParameters.neuron
    paramEvokedUp = evokedUpNWParameters.network

    if cell_generator is None:
        cell = scp.create_cell(cellParam, scaleFunc=scale_apical)
    else:
        logger.warning(
            "cell is generated by cell_generator. cell_param is ignored!")
        cell = cell_generator()

    seed = '00000'
    uniqueID = 'seed' + str(seed) + '_pid' + str(os.getpid())
    if auto_organize_results_folder:
        dirName = os.path.join(utils.resolve_db_path(dirPrefix), 'results', \
                           time.strftime('%Y%m%d-%H%M') + '_' + str(uniqueID) + '_running')
    else:
        dirName = dirPrefix

    if not os.path.exists(dirName):
        os.makedirs(dirName)
    with open(os.path.join(dirName, 'hostname_' + socket.gethostname()),
              'w') as f:
        pass

    ret_df = pd.DataFrame(dict(synapse_file = synapse_activation_files, \
                      number = ['%07d' % n for n in range(len(synapse_activation_files))]))
    ret_df.to_csv(os.path.join(dirName, 'synapse_file_paths.csv'), index=False)

    vTraces = []
    tTraces = []
    recordingSiteFiles = neuronParameters.sim.recordingSites
    recSiteManagers = []
    for recFile in recordingSiteFiles:
        recSiteManagers.append(sca.RecordingSiteManager(recFile, cell))

    tOffset = 0.0  # avoid numerical transients
    neuronParameters.sim.tStop = tStop
    dt = neuronParameters.sim.dt
    offsetBin = int(tOffset / dt + 0.5)

    nRun = 0

    if post_hook:  ##
        post_hook_list = []  ##

    for synfile in synapse_activation_files:
        synParametersEvoked = paramEvokedUp

        startTime = time.time()
        evokedNW = scp.NetworkMapper(cell, synParametersEvoked,
                                     neuronParameters.sim)
        #        evokedNW.create_saved_network2()
        evokedNW.reconnect_saved_synapses(synfile)

        stopTime = time.time()
        setupdt = stopTime - startTime
        logger.info('Network setup time: {:.2f} s'.format(setupdt))

        synTypes = list(cell.synapses.keys())
        synTypes.sort()

        logger.info('Testing evoked response properties run {:d} of {:d}'.format(
            nRun + 1, len(synapse_activation_files)))
        tVec = h.Vector()
        tVec.record(h._ref_t)
        startTime = time.time()
        scp.init_neuron_run(neuronParameters.sim,
                            vardt=False)  #trigger the actual simulation
        stopTime = time.time()
        simdt = stopTime - startTime
        logger.info('NEURON runtime: {:.2f} s'.format(simdt))

        vmSoma = np.array(cell.soma.recVList[0])
        t = np.array(tVec)
        cell.t = t  ##
        vTraces.append(np.array(vmSoma[offsetBin:])), tTraces.append(
            np.array(t[offsetBin:]))
        for RSManager in recSiteManagers:
            RSManager.update_recordings()

        logger.info('writing simulation results')
        fname = 'simulation'
        fname += '_run%07d' % nRun

        synName = dirName + '/' + fname + '_synapses.csv'
        logger.info('computing active synapse properties')
        sca.compute_synapse_distances_times(
            synName, cell, t,
            synTypes)  #calls scp.write_synapse_activation_file
        preSynCellsName = dirName + '/' + fname + '_presynaptic_cells.csv'
        scp.write_presynaptic_spike_times(preSynCellsName, evokedNW.cells)

        nRun += 1

        if post_hook:  ##
            dummy = {}
            for name in post_hook:
                dummy[name] = post_hook[name](cell)
            post_hook_list.append(dummy)

        cell.re_init_cell()
        evokedNW.re_init_network()

        logger.info('-------------------------------')

    vTraces = np.array(vTraces)
    dendTraces = []
    scp.write_all_traces(dirName + '/' + uniqueID + '_vm_all_traces.csv',
                         t[offsetBin:], vTraces)
    for RSManager in recSiteManagers:
        for recSite in RSManager.recordingSites:
            tmpTraces = []
            for vTrace in recSite.vRecordings:
                tmpTraces.append(vTrace[offsetBin:])
            recSiteName = dirName + '/' + uniqueID + '_' + recSite.label + '_vm_dend_traces.csv'
            scp.write_all_traces(recSiteName, t[offsetBin:], tmpTraces)
            dendTraces.append(tmpTraces)
    dendTraces = np.array(dendTraces)

    logger.info('writing simulation parameter files')
    neuronParameters.save(
        os.path.join(dirName, uniqueID + '_neuron_model.param'))
    evokedUpNWParameters.save(
        os.path.join(dirName, uniqueID + '_network_model.param'))

    if auto_organize_results_folder:
        dirName_final = os.path.join(utils.resolve_db_path(dirPrefix), 'results', \
                               time.strftime('%Y%m%d-%H%M') + '_' + str(uniqueID))
        os.rename(dirName, dirName_final)
        dirName = dirName_final

    logger.info('writing list of synapse files')
    if post_hook:  ##
        return ret_df, dirName, post_hook_list
    else:
        return ret_df, dirName



def run_existing_synapse_activations(
    cellParamName, 
    evokedUpParamName, 
    synapseActivation, 
    simName = '', 
    dirPrefix = '', 
    nprocs = 40, 
    tStop = 345, 
    silent = True, 
    scale_apical = None, 
    post_hook = {}, 
    auto_organize_results_folder = True, 
    cell_generator = None
    ):
    '''Recreate and resimulate a network-embedded neuron simulation from a list of :ref:`syn_activation_format` files.
    
    Args:
        cellParamName (str): Path to a :ref:`cell_parameters_format` file 
        evokedUpParamName (str): Path to a :ref:`network_parameters_format` file
        synapseActivationGlob (list): List of paths to :ref:`syn_activation_format` files or globstring
        dirprefix (str): Path to the directory where the simulation results should be stored.
        nSweeps (int): Number of synapse activations per process.
        nprocs (int): Number of independent processes
        tStop (float): Time in ms at which the synaptic input should stop.
        silent (bool): If True, suppresses all output.
        scale_apical (float, DEPRECATED): Scaling factor for the apical dendrite.
        post_hook (dict): Dictionary of functions that are called after the simulation.
        auto_organize_results_folder (bool): If True, the results are stored in a subfolder of the results folder.
        cell_generator (function): Function that generates a cell object.
        
    Returns: 
        dask.delayed: Delayed object. Can be computed with arbitrary scheduler.
        
    Raises:
        NotImplementedError: If nprocs is not equal to 1.
        RuntimeError: If no files are found on the specified location.
        AssertionError: If synapseActivation is not a list.
        
    .. deprecated:: 0.1
        The `scale_apical` argument is deprecated and will be removed in a future version.
        Use the ``cell_modify_functions`` key in the :ref:`cell_parameters_format` file instead.
        
    See also:
        :py:meth:`simrun,rerun_db.rerun_db` to rerun simulations from a database, instead of a list
        of synapse activation files.
    '''

    if not auto_organize_results_folder:
        if not nprocs == 1:
            raise NotImplementedError()
    if isinstance(synapseActivation, str):
        synapseActivation = glob.glob(str)
        if not synapseActivation:
            raise RuntimeError(
                "Did not find any files on the specified location. Please provide list or globstring."
            )
    assert isinstance(synapseActivation, list)

    chunks = utils.chunkIt(synapseActivation, nprocs)

    myfun = lambda synapse_activation_files: _evoked_activity(
        cellParamName, 
        evokedUpParamName,
        synapse_activation_files,
        dirPrefix = dirPrefix,
        tStop = tStop, 
        scale_apical = scale_apical, 
        post_hook = post_hook,
        auto_organize_results_folder = auto_organize_results_folder, 
        cell_generator = cell_generator
        )
    if silent:
        myfun = utils.silence_stdout(myfun)

    d = [dask.delayed(myfun)(paths) for paths in chunks]
    return dask.delayed(lambda *args: args)(d)  
